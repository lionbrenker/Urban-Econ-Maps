<!DOCTYPE html>
<html>
<head>
    <title>Urban Econ Maps</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- MapLibre GL JS CSS -->
    <link href='https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css' rel='stylesheet' />
    <!-- MapLibre GL JS -->
    <script src='https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js'></script>
    <!-- Turf.js for GIS operations -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <!-- Our New Styles -->
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        #panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            width: 250px;
        }
    </style>
</head>
<body>

    <!-- The map container, which will fill the whole page -->
    <div id="map"></div>

    <!-- The HTML for our new floating control panel -->
    <div id="panel">
        <h2>Frankfurt Data</h2>
        
        <div id="city-selector">
            <h4>Select City:</h4>
            <select id="city-dropdown" style="width: 100%;"></select>
        </div>
        <hr> <!-- This adds a nice dividing line -->
        
        <div class="layer-control">
            <h4>Select Data Layer:</h4>
            <input type="radio" id="housing" name="layer" value="housing_price" checked>
            <label for="housing">Housing Prices (€/m²)</label><br>
            <input type="radio" id="population" name="layer" value="population_density">
            <label for="population">Population Density</label><br>
        </div>
    </div>

    <script>
        // --- 1. INITIALIZE THE MAP ---
        const map = new maplibregl.Map({
            container: 'map',
            style: `https://api.maptiler.com/maps/streets/style.json?key=8UPX2x4HfWayBX8z6OFn`,
            center: [10.4515, 51.1657], // Center of Germany
            zoom: 5 // Zoomed out to see the whole country
        });
        
        // --- GLOBAL VARIABLE to hold all our region data ---
        let allRegionsData = null;
        
        // --- 2. CITY SELECTION LOGIC ---
        const cityDropdown = document.getElementById('city-dropdown');
        
        function populateDropdown(geojsonData) {
            cityDropdown.innerHTML = '';
        
            if (!geojsonData || !geojsonData.features) {
                console.error("GeoJSON data is invalid or has no features.");
                return;
            }
        
            const sortedFeatures = [...geojsonData.features].sort((a, b) => {
                // --- THE FIX: Convert values to Strings BEFORE comparing ---
                const nameA = String(a.properties.krs_name_short || '');
                const nameB = String(b.properties.krs_name_short || '');
                return nameA.localeCompare(nameB);
            });
        
            sortedFeatures.forEach(feature => {
                const regionName = feature.properties.krs_name_short;
                if (regionName) {
                    const option = document.createElement('option');
                    option.value = regionName;
                    option.innerText = regionName;
                    cityDropdown.appendChild(option);
                }
            });
        
            setTimeout(() => {
                if (cityDropdown.value) {
                    selectRegionByName(cityDropdown.value);
                }
            }, 0);
        }

        function selectRegionByName(name) {
            if (!allRegionsData) return;
        
            const selectedFeature = allRegionsData.features.find(feature => String(feature.properties.krs_name_short) === name);
        
            if (!selectedFeature) {
                console.error("Could not find feature for region:", name);
                return; 
            }
        
            // Update the border layer immediately
            map.getSource('city-border-source').setData(selectedFeature.geometry);
        
            // Fly to the location
            map.flyTo({
                center: turf.centerOfMass(selectedFeature).geometry.coordinates,
                zoom: 12,
                essential: true
            });
        
            // --- NEW AND IMPROVED LOGIC ---
            // Create a function that will run ONLY when the map has finished moving
            const onMoveEnd = () => {
                // Now that we've arrived, query for the buildings
                const allBuildingFeatures = map.querySourceFeatures('composite', {
                    sourceLayer: 'building'
                });
        
                const buildingsInRegion = [];
        
                for (const building of allBuildingFeatures) {
                    // Using turf.booleanPointInPolygon is faster and more reliable
                    if (turf.booleanPointInPolygon(turf.centerOfMass(building), selectedFeature)) {
                        buildingsInRegion.push(building);
                    }
                }
        
                console.log(`Found ${buildingsInRegion.length} buildings inside ${name}.`);
        
                // Update our blue layer with the buildings we found
                map.getSource('buildings-in-region-source').setData({
                    'type': 'FeatureCollection',
                    'features': buildingsInRegion
                });
        
                // IMPORTANT: Remove this listener so it doesn't run again on the next map move
                map.off('moveend', onMoveEnd);
            };
        
            // Tell the map to listen for the 'moveend' event and run our function
            map.on('moveend', onMoveEnd);
        }
        
        // Change it to this:
        cityDropdown.addEventListener('change', (e) => {
            selectRegionByName(e.target.value);
        });
        
        
        // --- 3. MAP LOAD AND DATA FETCHING ---
        map.on('load', () => {
            // --- SETUP SOURCES AND LAYERS (these are initially empty) ---
            map.addSource('city-border-source', { 'type': 'geojson', 'data': null });
            map.addLayer({
                'id': 'city-border-layer',
                'type': 'line',
                'source': 'city-border-source',
                'paint': { 'line-color': '#0000ff', 'line-width': 4, 'line-dasharray': [2, 2] }
            });

            // Source and layer for drawing ONLY the buildings inside the selected region
            map.addSource('buildings-in-region-source', { 'type': 'geojson', 'data': null });
            map.addLayer({
                'id': 'buildings-in-region-layer',
                'type': 'fill',
                'source': 'buildings-in-region-source',
                'paint': {
                    'fill-color': '#3388ff', // The blue color
                    'fill-opacity': 0.8
                }
            }, 'city-border-layer'); // This optional argument places the blue buildings UNDER the border line
        
            // --- FETCH THE MAIN GEOJSON DATA ---
            fetch('germany-regions.geojson')
                .then(response => {
                    // Check if the file was found
                    if (!response.ok) {
                        // If not, throw an error that we can catch
                        throw new Error(`Could not find file. Server responded with a status of ${response.status}`);
                    }
                    // If it was found, try to parse it as JSON
                    return response.json();
                })
                .then(data => {
                    console.log("GeoJSON data loaded successfully.");
                    allRegionsData = data;
                    populateDropdown(allRegionsData); 
                })
                .catch(error => {
                    // If anything went wrong in the steps above, this will run
                    console.error("CRITICAL ERROR LOADING DATA:", error);
                    alert("Fatal Error: Could not load the germany-regions.geojson file. Please check the developer console for details.");
                });
                
            // --- CLICK HANDLER CAN REMAIN FOR FUTURE USE ---
            // --- NEW, MORE RELIABLE CLICK HANDLER ---
            map.on('click', (e) => {
                // Query all features at the clicked point, without specifying layers
                const features = map.queryRenderedFeatures(e.point);
            
                // If no features were clicked, clear any existing highlights and stop
                if (!features.length) {
                    map.getSource('highlight-building-source').setData({ 'type': 'FeatureCollection', 'features': [] });
                    map.getSource('highlight-road-source').setData({ 'type': 'FeatureCollection', 'features': [] });
                    return;
                }
            
                // The vector tiles have "source-layers" which are more stable than style layer names.
                // We look for the first feature that comes from the 'building' or 'transportation' source-layer.
                const buildingFeature = features.find(f => f.layer['source-layer'] === 'building');
                const roadFeature = features.find(f => f.layer['source-layer'] === 'transportation');
            
                // Prioritize highlighting the building if one was found
                if (buildingFeature) {
                    map.getSource('highlight-building-source').setData(buildingFeature.geometry);
                    map.getSource('highlight-road-source').setData({ 'type': 'FeatureCollection', 'features': [] }); // Clear road highlight
                } 
                // Otherwise, highlight the road if one was found
                else if (roadFeature) {
                    map.getSource('highlight-road-source').setData(roadFeature.geometry);
                    map.getSource('highlight-building-source').setData({ 'type': 'FeatureCollection', 'features': [] }); // Clear building highlight
                }
            });
        });

    </script>

</body>
</html>
